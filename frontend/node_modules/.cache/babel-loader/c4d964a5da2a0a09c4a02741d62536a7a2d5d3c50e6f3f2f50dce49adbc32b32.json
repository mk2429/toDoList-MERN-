{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\hp\\\\Downloads\\\\ToDoListUsingTypeScript\\\\my-app\\\\src\\\\Contexts\\\\InputArrayContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { useReducer, createContext, useContext } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst InputArrayContext = /*#__PURE__*/createContext(undefined);\nconst TasksListReducer = (state, action) => {\n  switch (action.type) {\n    case \"Add\":\n      // Perform the asynchronous add operation\n      addTask(action.task).then(updatedTasks => {\n        // Dispatch a new action to update the state with the updated tasks\n        return updatedTasks;\n      }).catch(error => {\n        console.error(\"Error adding task\", error);\n      });\n      return state;\n    case \"Delete\":\n      // Perform the asynchronous delete operation\n      deleteTask(action.task).then(updatedTasks => {\n        // Dispatch a new action to update the state with the updated tasks\n        return updatedTasks;\n      }).catch(error => {\n        console.error(\"Error deleting task\", error);\n      });\n      return state;\n    default:\n      return state;\n  }\n};\n_c = TasksListReducer;\nconst addTask = async task => {\n  try {\n    const response = await fetch(\"http://localhost:5000/api/addTask\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        task: task\n      })\n    });\n    const data = await response.json();\n    return data.tasks; // Assuming the response from the backend includes an array of tasks\n  } catch (error) {\n    throw new Error(\"Error adding task\");\n  }\n};\nconst deleteTask = async task => {\n  try {\n    const response = await fetch(\"http://localhost:5000/api/deleteTask\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        task: task\n      })\n    });\n    const data = await response.json();\n    return data.tasks; // Assuming the response from the backend includes an array of tasks\n  } catch (error) {\n    throw new Error(\"Error deleting task\");\n  }\n};\nexport const InputArrayProvider = _ref => {\n  _s();\n  let {\n    children\n  } = _ref;\n  const [TasksList, dispatch] = useReducer(TasksListReducer, []);\n  return /*#__PURE__*/_jsxDEV(InputArrayContext.Provider, {\n    value: {\n      TasksList,\n      dispatch\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 87,\n    columnNumber: 5\n  }, this);\n};\n_s(InputArrayProvider, \"W6vM6hex4aAIlZDEjtOSNUfT7xc=\");\n_c2 = InputArrayProvider;\nexport const useInputArray = () => {\n  _s2();\n  const context = useContext(InputArrayContext);\n  if (!context) {\n    throw new Error(\"Error with Input provider\");\n  }\n  return context;\n};\n\n// code for only frontend\n\n// import React, { useState, useReducer, useEffect, createContext, useContext } from \"react\";\n\n// type InputArrayType = {\n//     TasksList: string[];\n//     dispatch:React.Dispatch<TaskListAction>\n// }\n// type InputArrayProviderType = {\n//     children: React.ReactNode\n// }\n// type TaskListAction = {\n//     type: \"Add\" | \"Delete\";\n//     task: string;\n// }\n// const InputArrayContext = createContext<InputArrayType | undefined>(undefined);\n\n// const TasksListReducer = (state: string[], action: TaskListAction):string[] => {\n//     switch (action.type) {\n//         case \"Add\":\n//             return [...state,action.task];\n//         case \"Delete\":\n//             return state.filter(item => item !== action.task)\n//     }\n// }\n\n// export const InputArrayProvider = ({ children }: InputArrayProviderType) => {\n//     const [TasksList, dispatch] = useReducer(TasksListReducer, [])\n//     return(\n//         <InputArrayContext.Provider value={{TasksList,dispatch}}>\n//             {children}\n//         </InputArrayContext.Provider>\n//     )\n// }\n// export const useInputArray=() : InputArrayType=>{\n//     const context=useContext(InputArrayContext);\n//     if (!context) {\n//         throw new Error('error withrovider');\n//       }\n//       return context;\n// }\n_s2(useInputArray, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c, _c2;\n$RefreshReg$(_c, \"TasksListReducer\");\n$RefreshReg$(_c2, \"InputArrayProvider\");","map":{"version":3,"names":["React","useReducer","createContext","useContext","jsxDEV","_jsxDEV","InputArrayContext","undefined","TasksListReducer","state","action","type","addTask","task","then","updatedTasks","catch","error","console","deleteTask","_c","response","fetch","method","headers","body","JSON","stringify","data","json","tasks","Error","InputArrayProvider","_ref","_s","children","TasksList","dispatch","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c2","useInputArray","_s2","context","$RefreshReg$"],"sources":["C:/Users/hp/Downloads/ToDoListUsingTypeScript/my-app/src/Contexts/InputArrayContext.tsx"],"sourcesContent":["import React, { useState, useReducer, createContext, useContext } from \"react\";\r\n\r\ntype InputArrayType = {\r\n  TasksList: string[];\r\n  dispatch: React.Dispatch<TaskListAction>;\r\n};\r\n\r\ntype InputArrayProviderType = {\r\n  children: React.ReactNode;\r\n};\r\n\r\ntype TaskListAction =\r\n  | { type: \"Add\"; task: string }\r\n  | { type: \"Delete\"; task: string }\r\n  | { type: \"SetTasks\"; tasks: string[] };\r\n\r\nconst InputArrayContext = createContext<InputArrayType | undefined>(undefined);\r\n\r\nconst TasksListReducer = (state: string[], action: TaskListAction): string[] => {\r\n  switch (action.type) {\r\n    case \"Add\":\r\n      // Perform the asynchronous add operation\r\n      addTask(action.task)\r\n        .then((updatedTasks) => {\r\n          // Dispatch a new action to update the state with the updated tasks\r\n          return updatedTasks\r\n        })\r\n        .catch((error) => {\r\n          console.error(\"Error adding task\", error);\r\n        });\r\n      return state;\r\n\r\n    case \"Delete\":\r\n      // Perform the asynchronous delete operation\r\n      deleteTask(action.task)\r\n        .then((updatedTasks) => {\r\n          // Dispatch a new action to update the state with the updated tasks\r\n          return updatedTasks\r\n        })\r\n        .catch((error) => {\r\n          console.error(\"Error deleting task\", error);\r\n        });\r\n      return state;\r\n\r\n\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\nconst addTask = async (task: string): Promise<string[]> => {\r\n  try {\r\n    const response = await fetch(\"http://localhost:5000/api/addTask\", {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\"\r\n      },\r\n      body: JSON.stringify({ task:task })\r\n    });\r\n    const data = await response.json();\r\n    return data.tasks; // Assuming the response from the backend includes an array of tasks\r\n  } catch (error) {\r\n    throw new Error(\"Error adding task\");\r\n  }\r\n};\r\n\r\nconst deleteTask = async (task: string): Promise<string[]> => {\r\n  try {\r\n    const response = await fetch(\"http://localhost:5000/api/deleteTask\", {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\"\r\n      },\r\n      body: JSON.stringify({ task :task})\r\n    });\r\n    const data = await response.json();\r\n    return data.tasks; // Assuming the response from the backend includes an array of tasks\r\n  } catch (error) {\r\n    throw new Error(\"Error deleting task\");\r\n  }\r\n};\r\n\r\nexport const InputArrayProvider = ({ children }: InputArrayProviderType) => {\r\n  const [TasksList, dispatch] = useReducer(TasksListReducer, []);\r\n\r\n  return (\r\n    <InputArrayContext.Provider value={{ TasksList, dispatch }}>\r\n      {children}\r\n    </InputArrayContext.Provider>\r\n  );\r\n};\r\n\r\nexport const useInputArray = (): InputArrayType => {\r\n  const context = useContext(InputArrayContext);\r\n  if (!context) {\r\n    throw new Error(\"Error with Input provider\");\r\n  }\r\n  return context;\r\n};\r\n\r\n\r\n\r\n// code for only frontend\r\n\r\n\r\n// import React, { useState, useReducer, useEffect, createContext, useContext } from \"react\";\r\n\r\n// type InputArrayType = {\r\n//     TasksList: string[];\r\n//     dispatch:React.Dispatch<TaskListAction>\r\n// }\r\n// type InputArrayProviderType = {\r\n//     children: React.ReactNode\r\n// }\r\n// type TaskListAction = {\r\n//     type: \"Add\" | \"Delete\";\r\n//     task: string;\r\n// }\r\n// const InputArrayContext = createContext<InputArrayType | undefined>(undefined);\r\n\r\n// const TasksListReducer = (state: string[], action: TaskListAction):string[] => {\r\n//     switch (action.type) {\r\n//         case \"Add\":\r\n//             return [...state,action.task];\r\n//         case \"Delete\":\r\n//             return state.filter(item => item !== action.task)\r\n//     }\r\n// }\r\n\r\n// export const InputArrayProvider = ({ children }: InputArrayProviderType) => {\r\n//     const [TasksList, dispatch] = useReducer(TasksListReducer, [])\r\n//     return(\r\n//         <InputArrayContext.Provider value={{TasksList,dispatch}}>\r\n//             {children}\r\n//         </InputArrayContext.Provider>\r\n//     )\r\n// }\r\n// export const useInputArray=() : InputArrayType=>{\r\n//     const context=useContext(InputArrayContext);\r\n//     if (!context) {\r\n//         throw new Error('error withrovider');\r\n//       }\r\n//       return context;\r\n// }"],"mappings":";;;AAAA,OAAOA,KAAK,IAAcC,UAAU,EAAEC,aAAa,EAAEC,UAAU,QAAQ,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAgB/E,MAAMC,iBAAiB,gBAAGJ,aAAa,CAA6BK,SAAS,CAAC;AAE9E,MAAMC,gBAAgB,GAAGA,CAACC,KAAe,EAAEC,MAAsB,KAAe;EAC9E,QAAQA,MAAM,CAACC,IAAI;IACjB,KAAK,KAAK;MACR;MACAC,OAAO,CAACF,MAAM,CAACG,IAAI,CAAC,CACjBC,IAAI,CAAEC,YAAY,IAAK;QACtB;QACA,OAAOA,YAAY;MACrB,CAAC,CAAC,CACDC,KAAK,CAAEC,KAAK,IAAK;QAChBC,OAAO,CAACD,KAAK,CAAC,mBAAmB,EAAEA,KAAK,CAAC;MAC3C,CAAC,CAAC;MACJ,OAAOR,KAAK;IAEd,KAAK,QAAQ;MACX;MACAU,UAAU,CAACT,MAAM,CAACG,IAAI,CAAC,CACpBC,IAAI,CAAEC,YAAY,IAAK;QACtB;QACA,OAAOA,YAAY;MACrB,CAAC,CAAC,CACDC,KAAK,CAAEC,KAAK,IAAK;QAChBC,OAAO,CAACD,KAAK,CAAC,qBAAqB,EAAEA,KAAK,CAAC;MAC7C,CAAC,CAAC;MACJ,OAAOR,KAAK;IAGd;MACE,OAAOA,KAAK;EAChB;AACF,CAAC;AAACW,EAAA,GA9BIZ,gBAAgB;AAgCtB,MAAMI,OAAO,GAAG,MAAOC,IAAY,IAAwB;EACzD,IAAI;IACF,MAAMQ,QAAQ,GAAG,MAAMC,KAAK,CAAC,mCAAmC,EAAE;MAChEC,MAAM,EAAE,MAAM;MACdC,OAAO,EAAE;QACP,cAAc,EAAE;MAClB,CAAC;MACDC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;QAAEd,IAAI,EAACA;MAAK,CAAC;IACpC,CAAC,CAAC;IACF,MAAMe,IAAI,GAAG,MAAMP,QAAQ,CAACQ,IAAI,CAAC,CAAC;IAClC,OAAOD,IAAI,CAACE,KAAK,CAAC,CAAC;EACrB,CAAC,CAAC,OAAOb,KAAK,EAAE;IACd,MAAM,IAAIc,KAAK,CAAC,mBAAmB,CAAC;EACtC;AACF,CAAC;AAED,MAAMZ,UAAU,GAAG,MAAON,IAAY,IAAwB;EAC5D,IAAI;IACF,MAAMQ,QAAQ,GAAG,MAAMC,KAAK,CAAC,sCAAsC,EAAE;MACnEC,MAAM,EAAE,MAAM;MACdC,OAAO,EAAE;QACP,cAAc,EAAE;MAClB,CAAC;MACDC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;QAAEd,IAAI,EAAEA;MAAI,CAAC;IACpC,CAAC,CAAC;IACF,MAAMe,IAAI,GAAG,MAAMP,QAAQ,CAACQ,IAAI,CAAC,CAAC;IAClC,OAAOD,IAAI,CAACE,KAAK,CAAC,CAAC;EACrB,CAAC,CAAC,OAAOb,KAAK,EAAE;IACd,MAAM,IAAIc,KAAK,CAAC,qBAAqB,CAAC;EACxC;AACF,CAAC;AAED,OAAO,MAAMC,kBAAkB,GAAGC,IAAA,IAA0C;EAAAC,EAAA;EAAA,IAAzC;IAAEC;EAAiC,CAAC,GAAAF,IAAA;EACrE,MAAM,CAACG,SAAS,EAAEC,QAAQ,CAAC,GAAGpC,UAAU,CAACO,gBAAgB,EAAE,EAAE,CAAC;EAE9D,oBACEH,OAAA,CAACC,iBAAiB,CAACgC,QAAQ;IAACC,KAAK,EAAE;MAAEH,SAAS;MAAEC;IAAS,CAAE;IAAAF,QAAA,EACxDA;EAAQ;IAAAK,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACiB,CAAC;AAEjC,CAAC;AAACT,EAAA,CARWF,kBAAkB;AAAAY,GAAA,GAAlBZ,kBAAkB;AAU/B,OAAO,MAAMa,aAAa,GAAGA,CAAA,KAAsB;EAAAC,GAAA;EACjD,MAAMC,OAAO,GAAG5C,UAAU,CAACG,iBAAiB,CAAC;EAC7C,IAAI,CAACyC,OAAO,EAAE;IACZ,MAAM,IAAIhB,KAAK,CAAC,2BAA2B,CAAC;EAC9C;EACA,OAAOgB,OAAO;AAChB,CAAC;;AAID;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAAD,GAAA,CAnDaD,aAAa;AAAA,IAAAzB,EAAA,EAAAwB,GAAA;AAAAI,YAAA,CAAA5B,EAAA;AAAA4B,YAAA,CAAAJ,GAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}